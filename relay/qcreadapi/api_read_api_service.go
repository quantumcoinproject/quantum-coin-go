// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * QC Read API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: v1
 */

package qcreadapi

import (
	"fmt"
	"context"
	"encoding/json"
	"github.com/QuantumCoinProject/qc/log"
	"github.com/QuantumCoinProject/qc/params"
	"github.com/QuantumCoinProject/qc/relay"
	"github.com/QuantumCoinProject/qc/common"
	"github.com/QuantumCoinProject/qc/common/hexutil"
	"github.com/QuantumCoinProject/qc/rpc"
	"github.com/QuantumCoinProject/qc/cachemanager"
	"net/http"
	"errors"
	"github.com/mattn/go-colorable"
	"strconv"
	"strings"
	"time"
)

// ReadApiAPIService is a service that implements the logic for the ReadApiAPIServicer
// This service should implement the business logic for every endpoint for the ReadApiAPI API.
// Include any external packages or services that will be required by this service.
type ReadApiAPIService struct {
  DpUrl string
  cacheManager *cachemanager.CacheManager
	enableExtendedApis bool
}

type RPCTransaction struct {
	BlockHash        *common.Hash      `json:"blockHash"`
	BlockNumber      *hexutil.Big      `json:"blockNumber"`
	From             common.Address    `json:"from"`
	Gas              hexutil.Uint64    `json:"gas"`
	GasPrice         *hexutil.Big      `json:"gasPrice"`
	GasFeeCap        *hexutil.Big      `json:"maxFeePerGas,omitempty"`
	Hash             common.Hash       `json:"hash"`
	Input            hexutil.Bytes     `json:"input"`
	Nonce            hexutil.Uint64    `json:"nonce"`
	To               *common.Address   `json:"to"`
	TransactionIndex *hexutil.Uint64   `json:"transactionIndex"`
	Value            *hexutil.Big      `json:"value"`
	Type             hexutil.Uint64    `json:"type"`
}

// NewReadApiAPIService creates a default api service
func NewReadApiAPIService(dpUrl string, cacheManager *cachemanager.CacheManager,enableExtendedApis bool) (*ReadApiAPIService, error) {
	log.Root().SetHandler(log.LvlFilterHandler(log.Lvl(3), log.StreamHandler(colorable.NewColorableStderr(), log.TerminalFormat(true))))
	return &ReadApiAPIService{
		DpUrl: dpUrl,
		cacheManager: cacheManager,
		enableExtendedApis: enableExtendedApis,
	}, nil
}

// GetLatestBlockDetails - Get latest block details
func (s *ReadApiAPIService) GetLatestBlockDetails(ctx context.Context) (ImplResponse, error) {

	startTime := time.Now()

	log.Info(relay.InfoTitleLatestBlockDetails, relay.MsgDial, s.DpUrl)

	client, err := rpc.Dial(s.DpUrl)
	if err != nil {
		log.Error(relay.MsgDial, relay.MsgError, "errors.New(err.Error())", relay.MsgStatus, http.StatusInternalServerError)
		return Response(http.StatusInternalServerError, nil), errors.New(err.Error())
	}
	defer client.Close()

	var blockNumber *hexutil.Uint64
	err = client.CallContext(ctx, &blockNumber, "eth_blockNumber")
	if err != nil {
		log.Error(relay.MsgBlockNumber, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusInternalServerError)
		return Response(http.StatusInternalServerError, nil), errors.New(err.Error())
	}

	latestBlockNumber, err := hexutil.DecodeBig(blockNumber.String())
	if err != nil {
		log.Error(relay.MsgBlockNumber, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusBadRequest)
		return Response(http.StatusBadRequest, nil), errors.New(err.Error())
	}

	duration := time.Now().Sub(startTime)

	log.Info(relay.InfoTitleLatestBlockDetails, "blockNumber", latestBlockNumber.Int64(),  relay.MsgTimeDuration, duration, relay.MsgStatus, http.StatusOK)
	l := latestBlockNumber.Int64()
	return Response(http.StatusOK, BlockDetailsResponse{BlockDetails{&l}}), nil
}

// GetAccountDetails - Get account details
func (s *ReadApiAPIService) GetAccountDetails(ctx context.Context, address string) (ImplResponse, error) {

	startTime := time.Now()

	log.Info(relay.InfoTitleAccountDetails, relay.MsgDial, s.DpUrl)

	client, err := rpc.Dial(s.DpUrl)
	if err != nil {
		log.Error(relay.MsgDial, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusInternalServerError)
		return Response(http.StatusInternalServerError, nil), errors.New(err.Error())
	}
	defer client.Close()

	if !common.IsHexAddressDeep(address) {
		log.Error(relay.MsgAddress, relay.MsgAddress, address, relay.MsgError, relay.ErrInvalidAddress, relay.MsgStatus, http.StatusBadRequest)
		return Response(http.StatusBadRequest, nil), relay.ErrInvalidAddress
	}

	var balance *hexutil.Big
	err = client.CallContext(ctx, &balance, "eth_getBalance", common.HexToAddress(address), "latest")
	if err != nil {
		log.Error(relay.MsgBalance, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusInternalServerError)
		return Response(http.StatusInternalServerError, nil), errors.New(err.Error())
	}

	var nonce *hexutil.Big
	err = client.CallContext(ctx, &nonce, "eth_getTransactionCount", common.HexToAddress(address), "latest")
	if err != nil {
		log.Error(relay.MsgNonce, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusInternalServerError)
		return Response(http.StatusInternalServerError, nil), errors.New(err.Error())
	}

	var blockNumber *hexutil.Uint64
	err = client.CallContext(ctx, &blockNumber, "eth_blockNumber")
	if err != nil {
		log.Error(relay.MsgBlockNumber, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusInternalServerError)
		return Response(http.StatusInternalServerError, nil), errors.New(err.Error())
	}

	accountBalance, err := hexutil.DecodeBig(balance.String())
	if err != nil {
		log.Error(relay.MsgBalance, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusBadRequest)
		return Response(http.StatusBadRequest, nil), errors.New(err.Error())
	}

	accountNonce, err := hexutil.DecodeBig(nonce.String())
	if err != nil {
		log.Error(relay.MsgNonce, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusBadRequest)
		return Response(http.StatusBadRequest, nil), errors.New(err.Error())
	}

	latestBlockNumber, err := hexutil.DecodeBig(blockNumber.String())
	if err != nil {
		log.Error(relay.MsgBlockNumber, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusBadRequest)
		return Response(http.StatusBadRequest, nil), errors.New(err.Error())
	}

	b := accountBalance.String()
	n := accountNonce.Int64()
	l := latestBlockNumber.Int64()

	duration := time.Now().Sub(startTime)

	log.Info(relay.InfoTitleAccountDetails, relay.MsgAddress, address, relay.MsgTimeDuration, duration, relay.MsgStatus, http.StatusOK)

	return Response(http.StatusOK, AccountDetailsResponse{
		AccountDetails{&b,&n,&l}}), nil
}

// GetTransactionDetails - Get transaction Details
func (s *ReadApiAPIService) GetTransactionDetails(ctx context.Context, hash string) (ImplResponse, error) {

	startTime := time.Now()
	isDiscarded := false
	discardReason := ""
	log.Info(relay.InfoTitleTransaction, relay.MsgDial, s.DpUrl)

	client, err := rpc.Dial(s.DpUrl)
	if err != nil {
		log.Error(relay.MsgDial,relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusInternalServerError)
		return Response(http.StatusInternalServerError, nil), errors.New(err.Error())
	}
	defer client.Close()

	if !common.IsHexAddressDeep(hash)  {
		log.Error(relay.MsgHash, relay.MsgHash, hash, relay.MsgError, relay.ErrInvalidHash, relay.MsgStatus, http.StatusBadRequest)
		return  Response(http.StatusBadRequest, nil), relay.ErrInvalidHash
	}

	var raw json.RawMessage
	err =  client.CallContext(ctx, &raw, "eth_getTransactionByHash", common.HexToHash(hash))
	if err != nil {
		log.Error(relay.MsgTransaction, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusInternalServerError)
		return  Response(http.StatusInternalServerError, nil), errors.New(err.Error())
	}

	if raw != nil {

		var rpcTxn  *RPCTransaction

		err = json.Unmarshal(raw, &rpcTxn);
		if err != nil {
			log.Error(relay.MsgNonce, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusBadRequest)
			return Response(http.StatusBadRequest, nil), errors.New(err.Error())
		}

		var blochHash string
		var blockNumber int64
		var from, gas, gasPrice, txnHash, input, to string

		if rpcTxn.BlockHash != nil{
			blochHash = rpcTxn.BlockHash.String()
		}
		if rpcTxn.BlockNumber != nil {
			b := rpcTxn.BlockNumber.ToInt()
			blockNumber = b.Int64()
		}

		from = rpcTxn.From.String()
		gas = rpcTxn.Gas.String()
		gasPrice = rpcTxn.GasPrice.String()
		txnHash = rpcTxn.Hash.String()
		input = rpcTxn.Input.String()

		if rpcTxn.To != nil {
			to = rpcTxn.To.String()
		}

		transNonce := rpcTxn.Nonce
		n, err := hexutil.DecodeBig(transNonce.String())
		if err != nil {
			log.Error(relay.MsgNonce, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusBadRequest)
			return  Response(http.StatusBadRequest, nil), errors.New(err.Error())
		}

		nonce := n.Int64()

		value := rpcTxn.Value.String()

		var receipt map[string]interface{}
		err =  client.CallContext(ctx, &receipt, "eth_getTransactionReceipt", common.HexToHash(hash))
		if err != nil {
			log.Error(relay.MsgTransactionReceipt, relay.MsgError, errors.New(err.Error()), relay.MsgStatus, http.StatusServiceUnavailable)
			return  Response(http.StatusServiceUnavailable, nil), errors.New(err.Error())
		}

		var transactionReceipt  TransactionReceipt
		if receipt != nil {
			cumulativeGasUsed := receipt["cumulativeGasUsed"].(string)
			effectiveGasPrice := receipt["effectiveGasPrice"].(string)
			gasUsed := receipt["gasUsed"].(string)
			status := receipt["status"].(string)
			txnReceiptHash := receipt["transactionHash"].(string)
			t := receipt["type"].(string)
			transactionReceipt =  TransactionReceipt{
				cumulativeGasUsed, effectiveGasPrice, gasUsed,
				status, txnReceiptHash, t}
		} else {
			duration := time.Now().Sub(startTime)

			log.Info(relay.InfoTitleTransaction, relay.MsgHash, hash, relay.MsgTimeDuration, duration, relay.MsgStatus, http.StatusOK)

			txnDetails := TransactionDetails{
				&blochHash, &blockNumber, from,gas, gasPrice, txnHash,
				input, &isDiscarded, &discardReason, nonce , &to,value,
				transactionReceipt}

			Dump(txnDetails)

			return  Response(http.StatusOK, TransactionResponse{txnDetails}),	nil
		}
		duration := time.Now().Sub(startTime)

		log.Info(relay.InfoTitleTransaction, relay.MsgHash, hash, relay.MsgTimeDuration, duration, relay.MsgStatus, http.StatusOK)

		txnDetails := TransactionDetails{
			&blochHash, &blockNumber, from,gas, gasPrice, txnHash,
			input, &isDiscarded, &discardReason, nonce , &to,value,
			transactionReceipt}

		Dump(txnDetails)

		return Response(http.StatusOK,TransactionResponse{txnDetails}),	nil
	}

	duration := time.Now().Sub(startTime)

	log.Info(relay.InfoTitleTransaction, relay.MsgHash, hash, relay.MsgTimeDuration, duration, relay.MsgStatus, http.StatusNoContent)

	return  Response(http.StatusNotFound,nil), nil
}

// GetBlockchainDetails - Get blockchain details
func (s *ReadApiAPIService) GetBlockchainDetails(ctx context.Context) (ImplResponse, error) {

	startTime := time.Now()

	log.Info(relay.InfoTitleGetBlockchainDetails)

	duration := time.Now().Sub(startTime)

	log.Info(relay.InfoTitleGetBlockchainDetails, relay.MsgTimeDuration, duration, relay.MsgStatus, http.StatusNoContent)

	if s.enableExtendedApis == false {
		return Response(http.StatusNotFound, nil), errors.New("Not Found")
	}

	getResponse, err := s.cacheManager.GetBlockchainDetails()
	if err != nil {
		return Response(http.StatusInternalServerError, nil), errors.New("Internal Server Error")
	}

	return Response(http.StatusOK,getResponse),	nil
}


// ListAccountTransactions - List account transactions
func (s *ReadApiAPIService) ListAccountTransactions(ctx context.Context, address string, pageNumber int64) (ImplResponse, error) {

	startTime := time.Now()

	log.Info(relay.InfoTitleListAccountTransactions)

	if common.IsHexAddressDeep(address) == false {
		return Response(http.StatusInternalServerError, nil), relay.ErrInvalidAddress
	}

	duration := time.Now().Sub(startTime)

	log.Info(relay.InfoTitleListAccountTransactions, relay.MsgAddress, address, relay.MsgTimeDuration, duration, relay.MsgStatus, http.StatusNoContent)

	listResponse, err := s.cacheManager.ListTransactionsByAccount(common.HexToAddress(address), pageNumber)
	if err != nil {
		return Response(http.StatusInternalServerError, nil), errors.New("Internal Server Error")
	}

	return Response(http.StatusOK,listResponse),	nil
}

// ListAccountPendingTransactions - List account pending transactions
func (s *ReadApiAPIService) ListAccountPendingTransactions(ctx context.Context, address string, pageNumber int64) (ImplResponse, error) {

	startTime := time.Now()

	log.Info(relay.InfoTitleListAccountPendingTransactions)

	if common.IsHexAddressDeep(address) == false {
		return Response(http.StatusInternalServerError, nil), relay.ErrInvalidAddress
	}

	duration := time.Now().Sub(startTime)

	log.Info(relay.InfoTitleListAccountPendingTransactions, relay.MsgAddress, address, relay.MsgTimeDuration, duration, relay.MsgStatus, http.StatusNoContent)

	listResponse, err := s.cacheManager.ListPendingTransactionsByAccount(common.HexToAddress(address), pageNumber)
	if err != nil {
		return Response(http.StatusInternalServerError, nil), errors.New("Internal Server Error")
	}

	return Response(http.StatusOK,listResponse),	nil
}

// QueryDetails - Query details
func (s *ReadApiAPIService) QueryDetails(ctx context.Context, queryTerm string) (ImplResponse, error) {
	queryTerm = strings.ToLower(queryTerm)
	startTime := time.Now()

	log.Info(relay.InfoTitleQueryDetails)

	duration := time.Now().Sub(startTime)

	log.Info(relay.InfoTitleQueryDetails, relay.MsgTimeDuration, duration, relay.MsgStatus, http.StatusNoContent)

	if s.enableExtendedApis == false {
		return Response(http.StatusNotFound, nil), errors.New("Not Found")
	}

	getResponse, err := s.cacheManager.GetBlockchainDetails()
	if err != nil {
		return Response(http.StatusInternalServerError, nil), errors.New("Internal Server Error")
	}

	result := ""
	if queryTerm == "totalcoins" {
		val, err :=  hexutil.DecodeBig(getResponse.TotalSupply)
		if err != nil {
			return Response(http.StatusInternalServerError, nil), errors.New("Internal Server Error")
		}
		result = strconv.FormatUint(params.WeiToEther(val).Uint64(), 10)
	} else if queryTerm == "circulating" {
		val, err :=  hexutil.DecodeBig(getResponse.CirculatingSupply)
		if err != nil {
			return Response(http.StatusInternalServerError, nil), errors.New("Internal Server Error")
		}
		result = strconv.FormatUint(params.WeiToEther(val).Uint64(), 10)
	}

	return Response(http.StatusOK,result),	nil
}

func Dump(data interface{}){
	b,_:=json.MarshalIndent(data, "", "  ")
	fmt.Print(string(b))
}